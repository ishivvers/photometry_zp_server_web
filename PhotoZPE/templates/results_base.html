{% extends "base.html" %}

{# This template lays out the sidebar and spectrum plots,
	and is used by the results pages only #}

{% block active2 %} class="active" {% endblock %}

{% block content %}
<div class="container">
  <div class="row-fluid">
    <div class="span4">
      <div class="hero-plain" id="overlay_hero">
		<!-- <h4 id="field"></h4> -->
		<h4 id="source">Select a source...</h4>
		<!-- draw the spectrum plot -->
      </div>
    </div><!--/span-->
    <div class="span8">
      <div class="hero-unit" id="main_hero">
		<!-- draw the spectrum plot -->
      </div><!--/hero -->
    </div><!--/span-->
  </div><!--/row-->
{% block content2 %}{% endblock %}
</div><!--/container-->


<script src="static/js/d3.v2.js"></script>

<!-- THE PLOTS -->
<script type="text/javascript">
//// THE SPECTRUM PLOT ////

// margins & size
var margin = {top: 10, right: 10, bottom: 20, left: 65},
    width = 600 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;

// scales
var xScale = d3.scale.log()
    .range([0, width]);
var yScale = d3.scale.linear()
    .range([height, 0]);

// axis generators
var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("bottom")
	.tickValues( [3000,4000,5000,6000,8000,10000,15000,20000] )
	.tickFormat(d3.format("d"));
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left")
	.ticks(5)
	.tickFormat(d3.format(".1e"));

// a line generator, called below
var line = d3.svg.line()
    .x(function(d) { return xScale(d.x); })
    .y(function(d) { return yScale(d.y); });

// the main image -- data added below in json call
var svg = d3.select("#main_hero").append("svg")
    .attr("height", "50%")
    .attr("width", "100%")
	.attr("viewBox", "0 0 600 300")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");	

// insert the (empty) lines and axes into svg
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")");
svg.append("g")
    .attr("class", "y axis");
svg.append("path")
    .attr("class", "line");
// axis labels, invisible until plot is drawn
svg.append("text")
	.attr("class", "x label")
	.attr("text-anchor", "end")
	.attr("x", width-5)
	.attr("y", height-8)
	.text("wavelength (A)")
	.attr("opacity", 0.0);
svg.append("text")
	.attr("class", "y label")
	.attr("text-anchor", "end")
	.attr("y", 12)
	.attr("transform", "rotate(-90)")
	.text("Flux (erg/s/cm^2/A)")
	.attr("opacity", 0.0);

// create a variable to contain the displayed SED (used below)
var SED = svg.append("svg:g")
             .attr("id", "SED");

// some feedback text so user knows what to do next
svg.append("text")
    .attr("class", "loading")
    .text("Select a source...")
    .attr("x", function () { return width/2-50; })
    .attr("y", function () { return height/2; });

function draw_spectrum( spec_id, sed_index, ra, dec ) {
	// remove the loading text:
	svg.selectAll(".loading").remove();
	// if there are already circles around, remove them
	svg.selectAll(".circle").remove();
	
	// put in the line plot with a json call to serve_spectrum:
	d3.json( "{{ url_for('serve_spectrum') }}?spec="+String(spec_id)+"&index="+String(sed_index), function(data) {
		// parse the domains, and put into the scales
		xScale.domain([ d3.min(data, function(d){return d.x;}), d3.max(data, function(d){return d.x;}) ]);
		yScale.domain([ d3.min(data, function(d){ return d.y;}), d3.max(data, function(d){return d.y;}) ]);

		// bind the data to our line plot, using the line generator above
		svg.select("path.line").data( [data] );

       // within this callback, make a call to build the scatterplot
       draw_scatterplot( sed_index );
       // draw the image
       draw();
       // and update the text
       update_text(sed_index, spec_id, ra, dec);
	});
};

function draw_scatterplot( sed_index ) {
	// insert the scatterplot with a json call to serve_mags
	d3.json( "{{ url_for('serve_sed_flams') }}?index="+String(sed_index), function(data) {

		svg.selectAll("circle")
			.data(data).enter().append("circle")
			.attr("class", "circle")
			.attr("cx", function(d) { return xScale(d.x);})
			.attr("cy", function(d) { return yScale(d.y);})
			.attr("stroke", function(d) {
				if (d.modeled == 'm') { return "steelblue" }
				else { return "black"}
			})
			.transition()
			  .delay(100)
	          .duration(200)
			  .attr("r", 12);

		// use the loading class for any text that gets updated each time
		for ( var i=0; i<data.length; i++) {
			svg.append("text")
				.attr("class", "loading")
				.attr("x", xScale(data[i].x)-4)
				.attr("y", yScale(data[i].y)+5)
				.text(data[i].name);
		};
	});
};

function draw() {
	svg.select("g.x.axis").call(xAxis);
	svg.select("g.y.axis").call(yAxis);
	svg.selectAll(".label").attr("opacity",1.0);
	svg.select("path.line")
		.transition()
        .duration(300)
		.attr("d", line);
}

// function to change the body text, displaying feedback for selected source
function update_text(sed_index, spec_id, ra, dec) {
	// first set the text to the active source ra,dec
	document.getElementById("source").innerHTML = 'RA, Dec: <a target="_blank" href="http://simbad.u-strasbg.fr/simbad/sim-coo?output.format=HTML&Coord='+
						String(ra)+'%20'+String(dec)+'&Radius=50&Radius.unit=arcsec">'+
						String(d3.round(ra, 5))+'&deg;, '+String(d3.round(dec, 5))+'&deg;</a>'
	// then update the magnitudes table and the stellar type label
	var xmlhttp=new XMLHttpRequest();
	xmlhttp.onreadystatechange=function() {
	  if (xmlhttp.readyState==4 && xmlhttp.status==200) {
			eval("var reply="+xmlhttp.responseText);
			for (var i=0; i<reply.length; i++) {
				if (reply[i].name=='spec_type') {
					svg.append("text")
					    .attr("class", "loading")
					    .text('Stellar type: '+reply[i].value)
					    .attr("x", function () { return width-110; })
					    .attr("y", 10 );
					document.getElementById("bestfit").innerHTML = "Best-fit stellar type: "+reply[i].value;
				}
				else {
					var cells = document.getElementById("tr_"+reply[i].name).childNodes;
					cells[2].childNodes[0].replaceData( 0, 10, reply[i].y.toFixed(2));
					cells[3].childNodes[0].replaceData( 0, 10, reply[i].err.toFixed(3));
					cells[4].childNodes[0].replaceData( 0, 10, reply[i].modeled);
				}
	        };
	  };
	};
	xmlhttp.open("GET","{{ url_for('serve_sed_mags') }}?index="+String(sed_index)+"&spec="+String(spec_id),true);
	xmlhttp.send();
};


// THE IMAGE OVERLAY //

var coords = {{coords}};
var field_center = {{field_center}};
var field_width = {{field_width}};

// set the field center text
//document.getElementById("field").innerHTML = 'Field: '+String(d3.round(field_center[0], 4))+'&deg;, '+String(d3.round(field_center[1], 4))+'&deg;';

var width2 = 400, height2 = 400;

var x = d3.scale.linear()
    .domain([field_width/2, -field_width/2])
    .range([0, width2]);

var y = d3.scale.linear()
    .domain([-field_width/2, field_width/2])
    .range([height2, 0]);

// a function to define a scale bar size
function scale_width( size ) {
	// with size in arcseconds
	// returns [scalebar size, text]
	if (size < 10) {
		return [x(1/60)-x(0), '1"']
	}
	else if (size < 100) {
		return [x(-10/60)-x(0), '10"']
	}
	else if (size < 250) {
		return [x(-25/60)-x(0), '25"']
	}
	else if (size < 500) {
		return [x(-50/60)-x(0), '50"']
	}
	else if (size < 1000) {
		return [x(-100/60)-x(0), '100"']
	}
	else {
		return [x(-250/60)-x(0), '250"']
	}
}

var svg2 = d3.select("#overlay_hero").append("svg")
    .attr("height", "53%")
    .attr("width", "100%")
	.attr("viewBox", "0 0 "+String(height2)+" "+String(width2));

// the background image of stars, from DSS image server
svg2.append("image")
	.attr("xlink:href", "http://archive.stsci.edu/cgi-bin/dss_search?v=3&r=" +
		String(d3.round(field_center[0],8)) + "&d=" + String(d3.round(field_center[1],8)) + 
		"&h=" + String(d3.round(field_width, 8)) + "&w=" + String(d3.round(field_width, 8)) + 
		"&f=gif&c=none&fov=NONE&e=J2000")
	.attr("width", width2)
	.attr("height", height2);

// the compass rose and the scale bar
// first, define the markers
var defs = svg2.append("svg:defs");
defs.append("svg:marker")
	.attr("id","triangle")
	.attr("class","compass")
	.attr("viewBox","0 0 10 10").attr("refX",0).attr("refY", 5)
	.attr("markerUnits","strokeWidth")
	.attr("markerWidth",4).attr("markerHeight",3)
	.attr("orient","auto")
	.append("svg:path")
	.attr("d", "M 0 0 L 10 5 L 0 10 z");
defs.append("svg:marker")
	.attr("id","bar")
	.attr("class","compass")
	.attr("viewBox","0 0 10 10").attr("refX",0).attr("refY", 2.5)
	.attr("markerUnits","strokeWidth")
	.attr("markerWidth",10).attr("markerHeight",10)
	.attr("orient","auto")
	.append("svg:path")
	.attr("d", "M 0 -5 L 0 5 z");
// now, define the compass rose
svg2.append("svg:line")  //east
	.attr("class","compass")
	.attr("x1", width2-10)
	.attr("y1", height2-10)
	.attr("x2", width2-50)
	.attr("y2", height2-10)
	.attr("marker-end", "url(#triangle)");
svg2.append("text")
    .attr("class", "compass_txt")
    .text("E")
    .attr("x", width2-70)
    .attr("y", height2-5);
svg2.append("svg:line") //north
	.attr("class","compass")
	.attr("x1", width2-10)
	.attr("y1", height2-10)
	.attr("x2", width2-10)
	.attr("y2", height2-50)
	.attr("marker-end", "url(#triangle)");
svg2.append("text")
    .attr("class", "compass_txt")
    .text("N")
    .attr("x", width2-15)
    .attr("y", height2-58);
// and finally, define the scale bar
svg2.append("svg:line") //scale bar
	.attr("class", "compass")
	.attr("x1", 10)
	.attr("y1", height2-10)
	.attr("x2", 10+scale_width(field_width*60)[0])
	.attr("y2", height2-10)
	.attr("marker-start", "url(#bar)")
	.attr("marker-end", "url(#bar)");
svg2.append("text")
    .attr("class", "compass_txt")
    .text(scale_width(field_width*60)[1])
    .attr("x", 5+(scale_width(field_width*60)[0]/2))
    .attr("y", height2-20);

// put in all of the star markers
var rad = 8;
svg2.selectAll(".dot")
    .data(coords)
  .enter().append("circle")
    .attr("class", "dot")
    .attr("cx", function(d){ return x(d[2]); })
    .attr("cy", function(d){ return y(d[3]); })
    .attr("r", rad)
	.on("mouseover", function(d) {
		d3.select(this).transition().duration(150).attr("r",rad+3); })
	.on("mouseout", function(d) {
		d3.select(this).transition().duration(150).attr("r",rad); })
	.on("mousedown", function(d) { 
		draw_spectrum(d[4], d[5], d[0], d[1]);
		d3.select(this).attr("stroke", "firebrick");
		});

{% block more_javascript %}{% endblock %}
</script>

{% endblock %}

