{% extends "base.html" %}

{# This template lays out the sidebar and spectrum plots,
	and is used by the results pages only #}

{% block active2 %} class="active" {% endblock %}

{% block content %}
<div class="container-fluid">
  <div class="row-fluid">
    <div class="span4">
      <div class="well sidebar-nav pre-scrollable">
        <ul class="nav nav-list">
          <li class="nav-header">Sources (RA,DEC)</li>
		  <!-- add class="active" to add highlighting -->
		  {% for spec_id in spec_ids %}
            <li id="source_{{loop.index-1}}"><a href="#" onclick="draw_spectrum({{ spec_id }}, {{ loop.index-1 }})"> ({{ coords[loop.index-1][0] }}, {{ coords[loop.index-1][1] }}) </a></li>
		  {% endfor %}
        </ul>
      </div><!--/.well -->
    </div><!--/span-->
    <div class="span8">
      <div class="hero-unit" id="main_hero">
		<!-- draw the spectrum plot -->
      </div><!--/hero -->

	{% block content2 %}{% endblock %}

    </div><!--/span-->
  </div><!--/row-->
</div><!--/container-->



<script src="static/js/d3.v2.js"></script>

<!-- THE PLOTS -->
<script type="text/javascript">
//// THE SPECTRUM PLOT ////

// margins & size
var margin = {top: 10, right: 10, bottom: 20, left: 65},
    width = 600 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;

// scales
var xScale = d3.scale.log()
    .range([0, width]);
var yScale = d3.scale.linear()
    .range([height, 0]);

// axis generators
var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("bottom")
	.tickValues( [3000,4000,5000,6000,8000,10000,15000,20000] )
	.tickFormat(d3.format("d"));
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left")
	.ticks(5)
	.tickFormat(d3.format(".1e"));

// a line generator, called below
var line = d3.svg.line()
    .x(function(d) { return xScale(d.x); })
    .y(function(d) { return yScale(d.y); });

// the main image -- data added below in json call
var svg = d3.select("#main_hero").append("svg")
    .attr("height", "50%")
    .attr("width", "100%")
	.attr("viewBox", "0 0 600 300")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");	

// insert the (empty) lines and axes into svg
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")");
svg.append("g")
    .attr("class", "y axis");
svg.append("path")
    .attr("class", "line");
// axis labels, invisible until plot is drawn
svg.append("text")
	.attr("class", "x label")
	.attr("text-anchor", "end")
	.attr("x", width-5)
	.attr("y", height-8)
	.text("wavelength (A)")
	.attr("opacity", 0.0);
svg.append("text")
	.attr("class", "y label")
	.attr("text-anchor", "end")
	.attr("y", 12)
	.attr("transform", "rotate(-90)")
	.text("Flux (erg/s/cm^2/A)")
	.attr("opacity", 0.0);

// create a variable to contain the displayed SED (used below)
var SED = svg.append("svg:g")
             .attr("id", "SED");

// some feedback text so user knows what to do next
svg.append("text")
    .attr("class", "loading")
    .text("Choose a source to inspect...")
    .attr("x", function () { return width/2-125; })
    .attr("y", function () { return height/2; });

function draw_spectrum( spec_id, sed_index ) {
	// remove the loading text:
	svg.selectAll(".loading").remove();
	// if there are already circles around, remove them
	svg.selectAll(".circle").remove();
	
	// put in the line plot with a json call to serve_spectrum:
	d3.json( "{{ url_for('serve_spectrum') }}?spec="+String(spec_id)+"&index="+String(sed_index), function(data) {
		// parse the domains, and put into the scales
		xScale.domain([ d3.min(data, function(d){return d.x;}), d3.max(data, function(d){return d.x;}) ]);
		yScale.domain([ d3.min(data, function(d){ return d.y;}), d3.max(data, function(d){return d.y;}) ]);

		// bind the data to our line plot, using the line generator above
		svg.select("path.line").data( [data] );

       // within this callback, make a call to build the scatterplot
       draw_scatterplot( sed_index );
       // draw the image
       draw();
       // and update the text
       update_text(sed_index, spec_id);
	});
};

function draw_scatterplot( sed_index ) {
	// insert the scatterplot with a json call to serve_mags
	d3.json( "{{ url_for('serve_sed_flams') }}?index="+String(sed_index), function(data) {
		/* I'd like to make sure that no observed mags are off the plot (i.e. for one bad point),
		    but this is not working and I do not understand why. Ignoring problem for now.
	    // check whether we need to expand the plot size
		if (d3.max(data, function(d){return d.y;}) > yScale.domain()[1]) {
			yScale.domain()[1] = d3.max(data, function(d){return d.y;});
		}
		if (d3.min(data, function(d){return d.y;}) < yScale.domain()[0]) {
			yScale.domain()[0] = d3.min(data, function(d){return d.y;});
		}
		*/

		svg.selectAll("circle")
			.data(data).enter().append("circle")
			.attr("class", "circle")
			.attr("cx", function(d) { return xScale(d.x);})
			.attr("cy", function(d) { return yScale(d.y);})
			.attr("stroke", function(d) {
				if (d.modeled == 'y') { return "steelblue" }
				else { return "black"}
			})
			.transition()
			  .delay(100)
	          .duration(200)
			  .attr("r", 12);

		// use the loading class for any text that gets updated each time
		for ( var i=0; i<data.length; i++) {
			svg.append("text")
				.attr("class", "loading")
				.attr("x", xScale(data[i].x)-4)
				.attr("y", yScale(data[i].y)+5)
				.text(data[i].name);
		};
	});
};

function draw() {
	svg.select("g.x.axis").call(xAxis);
	svg.select("g.y.axis").call(yAxis);
	svg.selectAll(".label").attr("opacity",1.0);
	svg.select("path.line")
		.transition()
        .duration(300)
		.attr("d", line);
}

// function to change the body text, displaying feedback for selected source
function update_text(sed_index, spec_id) {
	// first set the selected source as active
	//  remove active class from previous selection, and apply it to new selection
	var all_active_elements = document.getElementsByClassName("active");
	for (var i=0; i<all_active_elements.length; i++) { 
		if (all_active_elements[i].id !='') { // if id='', then this is a top navbar element
			all_active_elements[i].className = "";
		};
	};
	var list_element = document.getElementById("source_"+String(sed_index));
	list_element.className = "active";
	
	// then update the magnitudes table and the stellar type label
	var xmlhttp=new XMLHttpRequest();
	xmlhttp.onreadystatechange=function() {
	  if (xmlhttp.readyState==4 && xmlhttp.status==200) {
			eval("var reply="+xmlhttp.responseText);
			for (var i=0; i<reply.length; i++) {
				if (reply[i].name=='spec_type') {
					svg.append("text")
					    .attr("class", "loading")
					    .text(reply[i].value)
					    .attr("x", function () { return width-50; })
					    .attr("y", 10 );
				}
				else {
					var cells = document.getElementById("tr_"+reply[i].name).childNodes;
					cells[2].childNodes[0].replaceData( 0, 10, reply[i].y.toFixed(2));
					cells[3].childNodes[0].replaceData( 0, 10, reply[i].err.toFixed(3));
					cells[4].childNodes[0].replaceData( 0, 10, reply[i].modeled);
				}
	        };
	  };
	};
	xmlhttp.open("GET","{{ url_for('serve_sed_mags') }}?index="+String(sed_index)+"&spec="+String(spec_id),true);
	xmlhttp.send();
};

{% block more_javascript %}{% endblock %}
</script>

{% endblock %}
